
def xyzsh_quote (
    | sub -global ' |\\|"|\$|\*|\?|\[|\]|\{|\}|\&|\;|\(|\)' ( | add -number 0 \\ )
)

def xyzsh_dequote (
    | sub -global '(?<!\\)\\' ''
)

def program_completion (
    export PATH | split : | ary -local dirs

    dirs | each (
        | if(| rows -2 | = /) ( |print) else ( | add -number -2 / ) | var -local path

        ls $path | each (
            | var -local program

            print "$path$program" | if(| -x) (
                program
            )
        )
    )
)

def expand_tilda (
    ary ARGV -index 0 | var -local editing_line
    ary ARGV -index 1 | var -local inputing

    rl::delete_text $(editing_line | rindex -byte $inputing) $(rl::point)
    rl::insert_text $(eval "print $inputing"|chomp)
)

def file_completion (
    | split '(?<!\\) +' | lines -1 | var -local inputing
    | if(| rows -2..-1 | =~ '[^\\] ') ( print "" | var -local inputing)

    
    if(inputing | rows 0 | = \') (
        inputing | rows 1..-1 | var -local inputing
        print 1 | var -local SQuote
        print 0 | var -local DQuote
    ) elif(inputing | rows 0 | = \") (
        inputing | rows 1..-1 | var -local inputing
        print 0 | var -local SQuote
        print 1 | var -local DQuote
    ) else (
        print 0 | var -local SQuote
        print 0 | var -local DQuote
    )

    if(inputing | index -quiet /) (
        if(inputing | rows 0 | = \~) (
            | expand_tilda $(|print) $inputing

            rl::line_buffer | split '(?<!\\) +' | lines -1 | var -local inputing
            rl::line_buffer | rows -2..-1 | =~ '(?<!\\) ' && print "" | var -local inputing
        )

        sys::dirname $(inputing |chomp| if (|rows -1 | = /) ( |add aaa ) else ( | print ) )  | chomp | if(|rows -1 | = /) ( | print ) ( | add /) | var -local DIR

        ls -a $(DIR|xyzsh_dequote|chomp) | egrep -v '^\.$|^\.\.$' | each (
            | if (|chomp | add -number 0 $(DIR|xyzsh_dequote|chomp)/ | -d) (
                if(SQuote | = 1\n) (
                    |chomp | add -number 0 $DIR | add / | pomch
                ) else (
                    |chomp | xyzsh_quote | add -number 0 $DIR | add / | pomch
                )
            ) else (
                if(SQuote | = 1\n) (
                    |chomp | add -number 0 $DIR | add \' | pomch
                ) elif ( DQuote | = 1\n) (
                    |chomp | xyzsh_quote | add -number 0 $DIR | add \" | pomch
                ) else (
                    |chomp | xyzsh_quote | add -number 0 $DIR | pomch
                )
            )
        )

        print $DIR | length -byte |  rl::run( | var omit_head_of_completion_display_matches )
    ) else (
        if(inputing | rows 0 | = \~) (
            cat /etc/passwd | each ( 
                | split : | ary -local Field

                if(ary Field -size | -ge 7) (
                    print \~
                    ary Field -index 0 | chomp
                    print /\n
                )
            )
        ) else (
            ls -a | egrep -v '^\.$|^\.\.$' | each (
                | if (|chomp| -d) (
                    if(SQuote | = 1\n) (
                        | chomp | add / | pomch
                    ) else (
                        | chomp | xyzsh_quote | add / | pomch
                    )
                ) else (
                    if(SQuote | = 1\n) (
                        |chomp| add \' | pomch
                    ) elif (DQuote | = 1\n) (
                        |chomp| xyzsh_quote | add \" | pomch
                    ) else (
                        |chomp| xyzsh_quote | pomch
                    )
                )
            ) 
        )
    )
)

class object_completion (
    ary ARGV -index 0 | var -local Kind

    | split '(?<!\\) +' | lines -1 | var -local inputing
    | if(| rows -2..-1 | =~ '[^\\] ') ( print "" | var -local inputing)

    if(inputing | index -quiet ::) (
        inputing |chomp | split :: | lines 0..-2 | if( | -n) (
            | join ::| var -local PREFIX
            if(Kind | = all\n) (
                eval "${PREFIX}::show" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::' ) else (|print) ) | scan '(.+?:?:?):' | each ( | add -number 0 ${PREFIX}:: )
            ) else (
                eval "${PREFIX}::show" | egrep ": $Kind\$|: object\$" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::' ) else (|print) ) | scan '(.+?:?:?):' | each ( | add -number 0 ${PREFIX}:: )
            )
        )
    ) else (
        pwo  | var -local current
        while(true) (
            if(Kind | = all\n) (
                eval "${current}::show" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::' ) else (|print) ) | root::scan '(^.+?:?:?):' 
            ) else (
                eval "${current}::show" | egrep ": $Kind\$|: object\$" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::'  ) else (|print) ) | root::scan '(^.+?:?:?):' 
            )
            if(current | = root\n) ( break )
            current | strip | split :: | lines 0..-2| join :: | var -local current
        )
    )
)

root | egrep ': native function$' | egrep -v '^run: native function$|^show: native function$' | scan '(^.+):' | add sub\nsplit\nscan\n | each (
        | var -local command

        help $command | lines 1..-1 | scan '^-[a-zA-Z0-9-]+' |chomp| add -number 0 $command\a | hash -append -La COMPLETION_OPTIONS

        print <<<EOS
    completion "$command" (
        hash COMPLETION_OPTIONS -key "$command"
    )
EOS | eval
)

completion var (
    | object_completion var
    hash COMPLETION_OPTIONS -key var
)

completion ary (
    | object_completion array
    hash COMPLETION_OPTIONS -key ary
)

completion hash (
    | object_completion hash
    hash COMPLETION_OPTIONS -key hash
)

completion class (
    | object_completion class
    hash COMPLETION_OPTIONS -key class
)

completion def (
    | object_completion function
    hash COMPLETION_OPTIONS -key def
)

completion completion (
    | object_completion completion
    hash COMPLETION_OPTIONS -key completion
)

completion co (
    | object_completion object
)

completion ref (
    | object_completion all
    hash COMPLETION_OPTIONS -key ref
)

completion defined (
    | object_completion all
    hash COMPLETION_OPTIONS -key defined
)

completion objinfo (
    | object_completion all
    hash COMPLETION_OPTIONS -key defined
)

completion export (
    sys::env | scan '(.+?)='
)

completion sweep (
    self | egrep -v external\ program\$ | egrep -v native\ function\$ | egrep -v '^root:|^self:|^parent:|^run:'| root::scan '(^.+?):' 
    hash COMPLETION_OPTIONS -key sweep
)

completion help (
    root::self | egrep native\ function\$ | root::scan '(^.+?):' | add sub\nsplit\nscan\n | each ( | chomp | quote | pomch )
    hash COMPLETION_OPTIONS -key help
)

completion write (
    hash COMPLETION_OPTIONS -key write
)

completion unset (
    sys::env | scan '(.+?)='
)

completion load (
    | if(| index -quiet "-dynamic-library" ) (
        ls $XYZSH_EXT_PATH | (| print -read-from-error; | print)  | egrep '.so$|.dll$'
        ls ~/.xyzsh/lib | ( | print -read-from-error; | print ) | egrep '.so$|.dll$' 
    ) else (
        | file_completion
        hash COMPLETION_OPTIONS -key load
    )
)

completion cd (
    | file_completion | each ( | =~ '/$' && | print )
    print ../\n
    hash COMPLETION_OPTIONS -key cd
)

root::compl::run( root::object rl )

completion rl::help (
    rl::self | egrep native\ function\$ | egrep -v 'run|show' | root::scan '(^.+?):' | each ( | chomp | quote | pomch )
)

root::compl::run( root::object curses )

completion curses::help (
    curses::self | egrep native\ function\$ | egrep -v 'run|show' | root::scan '(^.+?):' | each ( | chomp | quote | pomch )
)

###################################################################################
### external program completoins ##################################################
###################################################################################
root::compl::run( root::object sys )

completion ./configure (
    ./configure --help | scan '(--[a-zA-Z0-9-]+)'
)

completion man sys::man (
    program_completion
)

completion sudo sys::sudo (
    | scan 'sudo .*' | chomp | split '(?<!\\) +' | wc -l | var -local input_num
    | scan 'sudo .*' | chomp | split '(?<!\\) +' | lines 1 | var -local program_name

    | if(| rows -2..-1 | =~ '[^\\] ') ( ++ input_num )

    if(input_num | -eq 2) (
        program_completion
    ) elif(input_num | -ge 3) (
        completion sys::$program_name
    )
)

completion make sys::make (
    print Makefile | -e && cat Makefile | scan '(.+?):'
)

completion git sys::git (
    git | awk '/The most commonly used git commands are:/,p' | lines 1..-2 | scan '^\s+(.+?)\s+' 
)

completion kill sys::kill (
    ps | ( | print -read-from-error > /dev/null; | print) | each ( | sub '^\s+' '' ) | selector | split | lines 0
    if(uname |= FreeBSD\n) (rl::clear_screen)
)

completion sys::__all__ (
    ARGV | var -local Program

    | split '(?<!\\) +' | lines -1 | var -local inputing
    | if(| rows -2..-1 | =~ '[^\\] ') ( print "" | var -local inputing)

    | file_completion

    ### option completion ###
    if(inputing | rows 0 | = -) (
        man $Program |> || raise "not found manual"
        |> sys::col -b | selector | scan '-\S+|--\S+' | var -local Option

        if(Option | chomp | -z) (
            raise "Please select a line which contains a option name"
        ) else (
            rl::delete_text $(| rindex -byte $inputing) $(rl::point)
            rl::insert_text $Option" "
        )
    )
)

completion __all__ (
    ARGV | var -local Program

    | split '(?<!\\) +' | lines -1 | var -local inputing
    | if(| rows -2..-1 | =~ '[^\\] ') ( print "" | var -local inputing)

    | file_completion

    ### option completion ###
    if(inputing | rows 0 | = -) (
        man $Program |> || raise "not found manual"
        |> sys::col -b | selector | scan '-\S+|--\S+' | var -local Option

        if(Option | chomp | -z) (
            raise "Please select a line which contains a option name"
        ) else (
            rl::delete_text $(| rindex -byte $inputing) $(rl::point)
            rl::insert_text $Option" "
        )
    )
)

