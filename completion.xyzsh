
def xyzsh_quote (
    | sub -global ' |\\|"|\$|\*|\?|\[|\]|\{|\}|\&|\;|\(|\)|-' ( | add -number 0 \\ )
)

def xyzsh_dequote (
    | sub -global '(?<!\\)\\' ''
)

def program_completion (
    export PATH | split : | ary -local dirs

    dirs | each (
        | if(| rows -2 | = /) ( |print) else ( | add -number -2 / ) | var -local path

        ls $path | each (
            | var -local program

            print "$path$program" | if(| -x) (
                program
            )
        )
    )
)

compl::run( object rl )

completion rl::help (
    rl::self | egrep native\ function\$ | root::scan '(^.+?):' | each ( | chomp | quote | pomch )
)

root | egrep ': native function$' | egrep -v '^run: native function$|^show: native function$' | scan '(^.+):' | add sub\nsplit\nscan\n | each (
        | var -local command

        help $command | lines 1..-1 | scan '^-[a-zA-Z0-9-]+' |chomp| add -number 0 $command\a | hash -append -La COMPLETION_OPTIONS

        print <<<EOS
    completion "$command" (
        hash COMPLETION_OPTIONS -key "$command"
    )
EOS | eval
)

class object_completion (
    ary ARGV -index 0 | var -local KIND

    | split '(?<!\\) +' | lines -1 | var -local inputing
    if(inputing | index -quiet ::) (
        inputing |chomp | split :: | lines 0..-2 | if( | -n) (
            | join ::| var -local PREFIX
            if(KIND | = all\n) (
                eval "${PREFIX}::show" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::' ) else (|print) ) | scan '(.+?:?:?):' | each ( | add -number 0 ${PREFIX}:: )
            ) else (
                eval "${PREFIX}::show" | egrep ": $KIND\$|: object\$" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::' ) else (|print) ) | scan '(.+?:?:?):' | each ( | add -number 0 ${PREFIX}:: )
            )
        )
    ) else (
        pwo  | var -local current
        while(true) (
            if(KIND | = all\n) (
                eval "${current}::show" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::' ) else (|print) ) | root::scan '(^.+?:?:?):' 
            ) else (
                eval "${current}::show" | egrep ": $KIND\$|: object\$" | each ( | if(|=~ ': object$') (| sub '(.+):' '\1:::'  ) else (|print) ) | root::scan '(^.+?:?:?):' 
            )
            if(current | = root\n) ( break )
            current | strip | split :: | lines 0..-2| join :: | var -local current
        )
    )
)

completion var (
    | object_completion var
    hash COMPLETION_OPTIONS -key var
)

completion ary (
    | object_completion array
    hash COMPLETION_OPTIONS -key ary
)

completion hash (
    | object_completion hash
    hash COMPLETION_OPTIONS -key hash
)

completion class (
    | object_completion class
    hash COMPLETION_OPTIONS -key class
)

completion def (
    | object_completion function
    hash COMPLETION_OPTIONS -key def
)

completion completion (
    | object_completion completion
    hash COMPLETION_OPTIONS -key completion
)

completion co (
    | object_completion object
)


completion ref (
    | object_completion all
    hash COMPLETION_OPTIONS -key ref
)

completion defined (
    | object_completion all
    hash COMPLETION_OPTIONS -key defined
)

completion objinfo (
    | object_completion all
    hash COMPLETION_OPTIONS -key defined
)

completion export (
    sys::env | scan '(.+?)='
)

completion sweep (
    self | egrep -v external\ program\$ | egrep -v native\ function\$ | egrep -v '^root:|^self:|^parent:|^run:'| root::scan '(^.+?):' 
    hash COMPLETION_OPTIONS -key sweep
)


completion help (
    root::self | egrep native\ function\$ | root::scan '(^.+?):' | add sub\nsplit\nscan\n | each ( | chomp | quote | pomch )
    hash COMPLETION_OPTIONS -key help
)

completion write (
    hash COMPLETION_OPTIONS -key write
)

completion ./configure (
    ./configure --help | scan '(--[a-zA-Z0-9-]+)'
)

completion man (
    program_completion
)

completion sudo (
    | scan 'sudo .*' | chomp | split '(?<!\\) +' | wc -l | var -local input_num
    | scan 'sudo .*' | chomp | split '(?<!\\) +' | lines 1 | var -local program_name

    if(input_num | -eq 2) (
        program_completion
    ) elif(input_num | -ge 3) (
        try(
            completion $program_name
        ) catch ()
    )
)

completion make (
    print Makefile | -e && cat Makefile | scan '(.+?):'
)

completion unset (
    sys::env | scan '(.+?)='
)

completion git (
    git | awk '/The most commonly used git commands are:/,p' | lines 1..-2 | scan '^\s+(.+?)\s+' 
)

completion kill (
    ps | each ( | sub '^\s+' '' ) | selector | split | lines 0
    rl::clear_screen
)

